/**
 * name:            DTDParser.jj
 * modified:        Apr 2, 2001
 * author:          John Gebbie
 * email:           j_gebbie@yahoo.com
 */
options{
  USER_CHAR_STREAM = true;
  STATIC = false;
  UNICODE_INPUT = true;
}
PARSER_BEGIN(DTDParser)
package net.sf.xpontus.view.editor.syntax.dtd;


import java.io.*;
import java.util.*;
import net.sf.xpontus.view.editor.syntax.*;
import net.sf.xpontus.view.editor.*;
import javax.swing.text.Segment;

public class DTDParser implements ILexer{
  public DTDParser(){
    this ((LexerInputStream)null);
  }
  public DTDParser(java.io.Reader reader){
    this (new LexerInputStream(reader));
  }


    public void ReInit(Reader reader){
        ReInit(new LexerInputStream(reader));
    }
 private List tokens = new ArrayList();
    public void switchTo(int newState) {
        this.token_source.SwitchTo(newState);
    }
 public int getLastTokenTypeOnLine(Segment text, int initialTokenType)
    {
        getTokens(text, initialTokenType, 0);

        return ((Token) tokens.get(tokens.size() - 1)).kind;
    }

    public List getTokens(Segment text, int initialTokenType, int startOffset)
    {
        tokens.clear();

        int state = DEFAULT;

        switch (initialTokenType)
        {
        case TEXT_IN_COMMENT:
            state = IN_COMMENT;

            break;

        case COMMENT_START:
            state = IN_COMMENT;

            break; 

        default:
            break;
        }

       

        try
        {
             ReInit(new LexerInputStream(
                new CharArrayReader(text.array, text.offset, text.count)));
        this.SwitchTo(state);

        Token currentToken = null;
        
            while ((currentToken = getNextToken()).kind != XMLLexerConstants.EOF)
            {
                
                tokens.add(currentToken);
            }
             
        }
        catch (TokenMgrError err)
        {
           tokens.add(new Token(this.token_source.input_stream.GetImage(), initialTokenType));
        }

        if (tokens.size() == 0)
        {
            
            tokens.add(new Token(""  , initialTokenType));
        }

        return tokens;
    }

}
PARSER_END(DTDParser)
TOKEN:{
  <LETTER:["A"-"Z", "a"-"z"]>
  | <DIGIT:["0"-"9"]>
  | <NAMECHAR:(<LETTER>
  | <DIGIT>
  | "."
  | "-"
  | "_"
  | ":")>
  | <FIXED:"#FIXED">
  | <IMPLIED:"#IMPLIED">
  | <PCDATA:"#PCDATA">
  | <REQUIRED:"#REQUIRED">
  | <ELEMENT:"<!ELEMENT">  
  | <ATTLIST:"<!ATTLIST">    
  | <CDATA:"CDATA">
  | <ANY:"ANY">
  | <EMPTY:"EMPTY">
  | <ID:"ID">
  | <IDREF:"IDREF">
  | <IDREFS:"IDREFS">
  | <ENTITY:"ENTITY">
  | <ENTITIES:"ENTITIES">
  | <NMTOKEN:"NMTOKEN">
  | <NMTOKENS:"NMTOKENS">
  | <NOTATION:"NOTATION">
  | <NAME:(<LETTER>
  | "_"
  | ":")(<NAMECHAR>)*>
  | <QUOTEDSTR:("'"(~["'"])*"'")
  | ("\""(~["\""])*"\"")>
}
TOKEN:{
  <(" "
  | "\t"
  | "\n"
  | "\r")+>
 
}

TOKEN:
{
  <COMMENT_START: "<!--">  : IN_COMMENT
}

<IN_COMMENT>
/* Comment is delimited by multiple character delimiter.
   The comment end regular expressions must throw TokenMgrError 
   to indicate that the lexer is in the middle of token at
   buffer boundaries!
*/
TOKEN:
{
  <TEXT_IN_COMMENT: ( (~["-"])+ | ("-" ~["-"])+ )+  >
| <ERR_IN_COMMENT: "--" ~[">"] > 
| <COMMENT_END: "-->" > :DEFAULT
}


void dtd():{}{
  (elementDecl()
  | attListDecl())*<EOF>
}
void elementDecl():{}{
  "<!ELEMENT"<NAME>contentSpec()">"
}
void contentSpec():{}{
  <EMPTY>
  | <ANY>
  | LOOKAHEAD(2)mixed()
  | children()
}
void mixed():{}{
  "("<PCDATA>(("|"<NAME>)*")*"
  | ")")
}
void children():{}{
  seqchoice()[modifier()]
}
void seqchoice():{}{
  "("cp()(choice()
  | seq())")"
}
void choice():{}{
  ("|"cp())+
}
void seq():{}{
  (","cp())*
}
void cp():{}{
  (<NAME>
  | seqchoice())[modifier()]
}
void modifier():{}{
  "*"
  | "+"
  | "?"
}
void attListDecl():{}{
  "<!ATTLIST"<NAME>(attribDef())*">"
}
void attribDef():{}{
  <NAME>attribType()defaultDecl()
}
void attribType():{}{
  stringType()
  | tokenizedType()
  | enumeratedType()
}
void stringType():{}{
  <CDATA>
}
void tokenizedType():{}{
  <ID>
  | <IDREF>
  | <IDREFS>
  | <ENTITY>
  | <ENTITIES>
  | <NMTOKEN>
  | <NMTOKENS>
}
void enumeratedType():{}{
  (notationType()
  | enumeration())
}
void notationType():{}{
  <NOTATION>"("<NAME>("|"<NAME>)*")"
}
void enumeration():{}{
  "("<NAME>("|"<NAME>)*")"
}
void defaultDecl():{}{
  <REQUIRED>
  | <IMPLIED>
  | ([<FIXED>]attribValue())
}
void attribValue():{}{
  <QUOTEDSTR>
}
