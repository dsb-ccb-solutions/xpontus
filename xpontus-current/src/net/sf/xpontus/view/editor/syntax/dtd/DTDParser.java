/* Generated By:JavaCC: Do not edit this line. DTDParser.java */
package net.sf.xpontus.view.editor.syntax.dtd;

import net.sf.xpontus.view.editor.ILexer;
import net.sf.xpontus.view.editor.syntax.CharStream;
import net.sf.xpontus.view.editor.syntax.FastCharStream;
import net.sf.xpontus.view.editor.syntax.ParseException;
import net.sf.xpontus.view.editor.syntax.Token;
import net.sf.xpontus.view.editor.syntax.TokenMgrError;


public class DTDParser implements ILexer, DTDParserConstants
  {
    static private int[] jj_la1_0;
    static private int[] jj_la1_1;

    static
      {
        jj_la1_0();
        jj_la1_1();
      }

    public DTDParserTokenManager token_source;
    public Token token;
    public Token jj_nt;
    private int jj_ntk;
    private Token jj_scanpos;
    private Token jj_lastpos;
    private int jj_la;
    public boolean lookingAhead = false;
    private boolean jj_semLA;
    private int jj_gen;
    final private int[] jj_la1 = new int[21];
    final private JJCalls[] jj_2_rtns = new JJCalls[1];
    private boolean jj_rescan = false;
    private int jj_gc = 0;
    final private LookaheadSuccess jj_ls = new LookaheadSuccess();
    private java.util.Vector jj_expentries = new java.util.Vector();
    private int[] jj_expentry;
    private int jj_kind = -1;
    private int[] jj_lasttokens = new int[100];
    private int jj_endpos;

    public DTDParser()
      {
        this((FastCharStream) null);
      }

    public DTDParser(java.io.Reader reader)
      {
        this(new FastCharStream(reader));
      }

    public DTDParser(CharStream stream)
      {
        token_source = new DTDParserTokenManager(stream);
        token = new Token();
        jj_ntk = -1;
        jj_gen = 0;

        for (int i = 0; i < 21; i++)
            jj_la1[i] = -1;

        for (int i = 0; i < jj_2_rtns.length; i++)
            jj_2_rtns[i] = new JJCalls();
      }

    public DTDParser(DTDParserTokenManager tm)
      {
        token_source = tm;
        token = new Token();
        jj_ntk = -1;
        jj_gen = 0;

        for (int i = 0; i < 21; i++)
            jj_la1[i] = -1;

        for (int i = 0; i < jj_2_rtns.length; i++)
            jj_2_rtns[i] = new JJCalls();
      }

    final public void dtd() throws ParseException
      {
label_1: 
        while (true)
          {
            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk)
              {
            case ELEMENT:
            case ATTLIST:
                ;

                break;

            default:
                jj_la1[0] = jj_gen;

                break label_1;
              }

            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk)
              {
            case ELEMENT:
                elementDecl();

                break;

            case ATTLIST:
                attListDecl();

                break;

            default:
                jj_la1[1] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
              }
          }

        jj_consume_token(0);
      }

    final public void elementDecl() throws ParseException
      {
        jj_consume_token(ELEMENT);
        jj_consume_token(NAME);
        contentSpec();
        jj_consume_token(26);
      }

    final public void contentSpec() throws ParseException
      {
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk)
          {
        case EMPTY:
            jj_consume_token(EMPTY);

            break;

        case ANY:
            jj_consume_token(ANY);

            break;

        default:
            jj_la1[2] = jj_gen;

            if (jj_2_1(2))
              {
                mixed();
              }
            else
              {
                switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk)
                  {
                case 27:
                    children();

                    break;

                default:
                    jj_la1[3] = jj_gen;
                    jj_consume_token(-1);
                    throw new ParseException();
                  }
              }
          }
      }

    final public void mixed() throws ParseException
      {
        jj_consume_token(27);
        jj_consume_token(PCDATA);

        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk)
          {
        case 28:
        case 29:
label_2: 
            while (true)
              {
                switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk)
                  {
                case 28:
                    ;

                    break;

                default:
                    jj_la1[4] = jj_gen;

                    break label_2;
                  }

                jj_consume_token(28);
                jj_consume_token(NAME);
              }

            jj_consume_token(29);

            break;

        case 30:
            jj_consume_token(30);

            break;

        default:
            jj_la1[5] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
      }

    final public void children() throws ParseException
      {
        seqchoice();

        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk)
          {
        case 32:
        case 33:
        case 34:
            modifier();

            break;

        default:
            jj_la1[6] = jj_gen;
            ;
          }
      }

    final public void seqchoice() throws ParseException
      {
        jj_consume_token(27);
        cp();

        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk)
          {
        case 28:
            choice();

            break;

        default:
            jj_la1[7] = jj_gen;
            seq();
          }

        jj_consume_token(30);
      }

    final public void choice() throws ParseException
      {
label_3: 
        while (true)
          {
            jj_consume_token(28);
            cp();

            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk)
              {
            case 28:
                ;

                break;

            default:
                jj_la1[8] = jj_gen;

                break label_3;
              }
          }
      }

    final public void seq() throws ParseException
      {
label_4: 
        while (true)
          {
            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk)
              {
            case 31:
                ;

                break;

            default:
                jj_la1[9] = jj_gen;

                break label_4;
              }

            jj_consume_token(31);
            cp();
          }
      }

    final public void cp() throws ParseException
      {
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk)
          {
        case NAME:
            jj_consume_token(NAME);

            break;

        case 27:
            seqchoice();

            break;

        default:
            jj_la1[10] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }

        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk)
          {
        case 32:
        case 33:
        case 34:
            modifier();

            break;

        default:
            jj_la1[11] = jj_gen;
            ;
          }
      }

    final public void modifier() throws ParseException
      {
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk)
          {
        case 32:
            jj_consume_token(32);

            break;

        case 33:
            jj_consume_token(33);

            break;

        case 34:
            jj_consume_token(34);

            break;

        default:
            jj_la1[12] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
      }

    final public void attListDecl() throws ParseException
      {
        jj_consume_token(ATTLIST);
        jj_consume_token(NAME);
label_5: 
        while (true)
          {
            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk)
              {
            case NAME:
                ;

                break;

            default:
                jj_la1[13] = jj_gen;

                break label_5;
              }

            attribDef();
          }

        jj_consume_token(26);
      }

    final public void attribDef() throws ParseException
      {
        jj_consume_token(NAME);
        attribType();
        defaultDecl();
      }

    final public void attribType() throws ParseException
      {
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk)
          {
        case CDATA:
            stringType();

            break;

        case ID:
        case IDREF:
        case IDREFS:
        case ENTITY:
        case ENTITIES:
        case NMTOKEN:
        case NMTOKENS:
            tokenizedType();

            break;

        case NOTATION:
        case 27:
            enumeratedType();

            break;

        default:
            jj_la1[14] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
      }

    final public void stringType() throws ParseException
      {
        jj_consume_token(CDATA);
      }

    final public void tokenizedType() throws ParseException
      {
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk)
          {
        case ID:
            jj_consume_token(ID);

            break;

        case IDREF:
            jj_consume_token(IDREF);

            break;

        case IDREFS:
            jj_consume_token(IDREFS);

            break;

        case ENTITY:
            jj_consume_token(ENTITY);

            break;

        case ENTITIES:
            jj_consume_token(ENTITIES);

            break;

        case NMTOKEN:
            jj_consume_token(NMTOKEN);

            break;

        case NMTOKENS:
            jj_consume_token(NMTOKENS);

            break;

        default:
            jj_la1[15] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
      }

    final public void enumeratedType() throws ParseException
      {
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk)
          {
        case NOTATION:
            notationType();

            break;

        case 27:
            enumeration();

            break;

        default:
            jj_la1[16] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
      }

    final public void notationType() throws ParseException
      {
        jj_consume_token(NOTATION);
        jj_consume_token(27);
        jj_consume_token(NAME);
label_6: 
        while (true)
          {
            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk)
              {
            case 28:
                ;

                break;

            default:
                jj_la1[17] = jj_gen;

                break label_6;
              }

            jj_consume_token(28);
            jj_consume_token(NAME);
          }

        jj_consume_token(30);
      }

    final public void enumeration() throws ParseException
      {
        jj_consume_token(27);
        jj_consume_token(NAME);
label_7: 
        while (true)
          {
            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk)
              {
            case 28:
                ;

                break;

            default:
                jj_la1[18] = jj_gen;

                break label_7;
              }

            jj_consume_token(28);
            jj_consume_token(NAME);
          }

        jj_consume_token(30);
      }

    final public void defaultDecl() throws ParseException
      {
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk)
          {
        case REQUIRED:
            jj_consume_token(REQUIRED);

            break;

        case IMPLIED:
            jj_consume_token(IMPLIED);

            break;

        case FIXED:
        case QUOTEDSTR:

            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk)
              {
            case FIXED:
                jj_consume_token(FIXED);

                break;

            default:
                jj_la1[19] = jj_gen;
                ;
              }

            attribValue();

            break;

        default:
            jj_la1[20] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
      }

    final public void attribValue() throws ParseException
      {
        jj_consume_token(QUOTEDSTR);
      }

    final private boolean jj_2_1(int xla)
      {
        jj_la = xla;
        jj_lastpos = jj_scanpos = token;

        try
          {
            return !jj_3_1();
          }
        catch (LookaheadSuccess ls)
          {
            return true;
          }
        finally
          {
            jj_save(0, xla);
          }
      }

    final private boolean jj_3_1()
      {
        if (jj_3R_8())
          {
            return true;
          }

        return false;
      }

    final private boolean jj_3R_8()
      {
        if (jj_scan_token(27))
          {
            return true;
          }

        if (jj_scan_token(PCDATA))
          {
            return true;
          }

        return false;
      }

    private static void jj_la1_0()
      {
        jj_la1_0 = new int[]
            {
                0x300, 0x300, 0x1800, 0x8000000, 0x10000000, 0x70000000, 0x0,
                0x10000000, 0x10000000, 0x80000000, 0x8200000, 0x0, 0x0,
                0x200000, 0x81fe400, 0xfe000, 0x8100000, 0x10000000, 0x10000000,
                0x10, 0x4000b0,
            };
      }

    private static void jj_la1_1()
      {
        jj_la1_1 = new int[]
            {
                0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x7, 0x0, 0x0, 0x0, 0x0, 0x7, 0x7,
                0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
            };
      }

    public void ReInit(CharStream stream)
      {
        token_source.ReInit(stream);
        token = new Token();
        jj_ntk = -1;
        jj_gen = 0;

        for (int i = 0; i < 21; i++)
            jj_la1[i] = -1;

        for (int i = 0; i < jj_2_rtns.length; i++)
            jj_2_rtns[i] = new JJCalls();
      }

    public void ReInit(DTDParserTokenManager tm)
      {
        token_source = tm;
        token = new Token();
        jj_ntk = -1;
        jj_gen = 0;

        for (int i = 0; i < 21; i++)
            jj_la1[i] = -1;

        for (int i = 0; i < jj_2_rtns.length; i++)
            jj_2_rtns[i] = new JJCalls();
      }

    final private Token jj_consume_token(int kind) throws ParseException
      {
        Token oldToken;

        if ((oldToken = token).next != null)
          {
            token = token.next;
          }
        else
        {
            token = token.next = token_source.getNextToken();
          }

        jj_ntk = -1;

        if (token.kind == kind)
          {
            jj_gen++;

            if (++jj_gc > 100)
              {
                jj_gc = 0;

                for (int i = 0; i < jj_2_rtns.length; i++)
                  {
                    JJCalls c = jj_2_rtns[i];

                    while (c != null)
                      {
                        if (c.gen < jj_gen)
                          {
                            c.first = null;
                          }

                        c = c.next;
                      }
                  }
              }

            return token;
          }

        token = oldToken;
        jj_kind = kind;
        throw generateParseException();
      }

    final private boolean jj_scan_token(int kind)
      {
        if (jj_scanpos == jj_lastpos)
          {
            jj_la--;

            if (jj_scanpos.next == null)
              {
                jj_lastpos = jj_scanpos = jj_scanpos.next = token_source.getNextToken();
              }
            else
              {
                jj_lastpos = jj_scanpos = jj_scanpos.next;
              }
          }
        else
          {
            jj_scanpos = jj_scanpos.next;
          }

        if (jj_rescan)
          {
            int i = 0;
            Token tok = token;

            while ((tok != null) && (tok != jj_scanpos))
              {
                i++;
                tok = tok.next;
              }

            if (tok != null)
              {
                jj_add_error_token(kind, i);
              }
          }

        if (jj_scanpos.kind != kind)
          {
            return true;
          }

        if ((jj_la == 0) && (jj_scanpos == jj_lastpos))
          {
            throw jj_ls;
          }

        return false;
      }

    final public Token getNextToken()
      {
        if (token.next != null)
          {
            token = token.next;
          }
        else
        {
            token = token.next = token_source.getNextToken();
          }

        jj_ntk = -1;
        jj_gen++;

        return token;
      }

    final public Token getToken(int index)
      {
        Token t = lookingAhead ? jj_scanpos : token;

        for (int i = 0; i < index; i++)
          {
            if (t.next != null)
              {
                t = t.next;
              }
            else
            {
                t = t.next = token_source.getNextToken();
              }
          }

        return t;
      }

    final private int jj_ntk()
      {
        if ((jj_nt = token.next) == null)
          {
            return (jj_ntk = (token.next = token_source.getNextToken()).kind);
          }
        else
        {
            return (jj_ntk = jj_nt.kind);
          }
      }

    private void jj_add_error_token(int kind, int pos)
      {
        if (pos >= 100)
          {
            return;
          }

        if (pos == (jj_endpos + 1))
          {
            jj_lasttokens[jj_endpos++] = kind;
          }
        else if (jj_endpos != 0)
          {
            jj_expentry = new int[jj_endpos];

            for (int i = 0; i < jj_endpos; i++)
              {
                jj_expentry[i] = jj_lasttokens[i];
              }

            boolean exists = false;

            for (java.util.Enumeration e = jj_expentries.elements();
                    e.hasMoreElements();)
              {
                int[] oldentry = (int[]) (e.nextElement());

                if (oldentry.length == jj_expentry.length)
                  {
                    exists = true;

                    for (int i = 0; i < jj_expentry.length; i++)
                      {
                        if (oldentry[i] != jj_expentry[i])
                          {
                            exists = false;

                            break;
                          }
                      }

                    if (exists)
                      {
                        break;
                      }
                  }
              }

            if (!exists)
              {
                jj_expentries.addElement(jj_expentry);
              }

            if (pos != 0)
              {
                jj_lasttokens[(jj_endpos = pos) - 1] = kind;
              }
          }
      }

    public ParseException generateParseException()
      {
        jj_expentries.removeAllElements();

        boolean[] la1tokens = new boolean[35];

        for (int i = 0; i < 35; i++)
          {
            la1tokens[i] = false;
          }

        if (jj_kind >= 0)
          {
            la1tokens[jj_kind] = true;
            jj_kind = -1;
          }

        for (int i = 0; i < 21; i++)
          {
            if (jj_la1[i] == jj_gen)
              {
                for (int j = 0; j < 32; j++)
                  {
                    if ((jj_la1_0[i] & (1 << j)) != 0)
                      {
                        la1tokens[j] = true;
                      }

                    if ((jj_la1_1[i] & (1 << j)) != 0)
                      {
                        la1tokens[32 + j] = true;
                      }
                  }
              }
          }

        for (int i = 0; i < 35; i++)
          {
            if (la1tokens[i])
              {
                jj_expentry = new int[1];
                jj_expentry[0] = i;
                jj_expentries.addElement(jj_expentry);
              }
          }

        jj_endpos = 0;
        jj_rescan_token();
        jj_add_error_token(0, 0);

        int[][] exptokseq = new int[jj_expentries.size()][];

        for (int i = 0; i < jj_expentries.size(); i++)
          {
            exptokseq[i] = (int[]) jj_expentries.elementAt(i);
          }

        return new ParseException(token, exptokseq, tokenImage);
      }

    final public void enable_tracing()
      {
      }

    final public void disable_tracing()
      {
      }

    final private void jj_rescan_token()
      {
        jj_rescan = true;

        for (int i = 0; i < 1; i++)
          {
            try
              {
                JJCalls p = jj_2_rtns[i];

                do
                  {
                    if (p.gen > jj_gen)
                      {
                        jj_la = p.arg;
                        jj_lastpos = jj_scanpos = p.first;

                        switch (i)
                          {
                        case 0:
                            jj_3_1();

                            break;
                          }
                      }

                    p = p.next;
                  }
                while (p != null);
              }
            catch (LookaheadSuccess ls)
              {
              }
          }

        jj_rescan = false;
      }

    final private void jj_save(int index, int xla)
      {
        JJCalls p = jj_2_rtns[index];

        while (p.gen > jj_gen)
          {
            if (p.next == null)
              {
                p = p.next = new JJCalls();

                break;
              }

            p = p.next;
          }

        p.gen = (jj_gen + xla) - jj_la;
        p.first = token;
        p.arg = xla;
      }

    static private final class LookaheadSuccess extends java.lang.Error
      {
      }

    static final class JJCalls
      {
        int gen;
        Token first;
        int arg;
        JJCalls next;
      }
  }
